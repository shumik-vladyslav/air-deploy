"use strict";function _interopDefault(a){return a&&"object"==typeof a&&"default"in a?a["default"]:a}var Elliptic=_interopDefault(require("elliptic")),BN=_interopDefault(require("bn.js")),crypto=_interopDefault(require("crypto")),safeBuffer=require("safe-buffer");const EC=Elliptic.ec("secp256k1"),CURVE=EC.curve,CURVE_ORDER=CURVE.n;class CurveUtils{static decodePoint(a){return CURVE.decodePoint(a)}}class RandomHelper{static randomBigInteger(a,b){let c;do c=new BN(RandomHelper.randomBytes(a.byteLength(),b));while(0<=c.cmp(a));return c}static randomBigIntegerBitLength(a,b){let c=Math.floor((a+7)/8),d=RandomHelper.randomBytes(c,b);if(0<c){d[0]&=(1<<8-(8*c-a))-1}return new BN(d)}static randomBytes(a,b){return b?b(a):crypto.randomBytes(a)}}class EllipticCurveDigester{digestPoints(a){let b=this.digestPointsToBytes(a);return new BN(b).mod(CURVE_ORDER)}digestPointsToBytes(a){let b=crypto.createHash("sha256");for(const c of a){let a=safeBuffer.Buffer.from(c.encodeCompressed());b.update(a)}return b.digest()}}const secondGenerator=CurveUtils.decodePoint(safeBuffer.Buffer.from("AiPvoPVC0Y2VhtJbHSSONzY07BNBZLpZVfMKt28Sb+kU","base64")),generateCommit=(a,b)=>{let c=CURVE.g,d=c.mul(a),e=secondGenerator.mul(b);return d.add(e)};class PedersenCommit{constructor(a,b){b||(b=RandomHelper.randomBigInteger(CURVE_ORDER)),this.randomness=b,this.commitment=generateCommit(a,b)}static verify(a,b,c){let d=generateCommit(b,c);if(!a.eq(d))throw new Error("Commit did not match expected values")}static verifyProofOfValue(a,b,c){let d=b.add(CURVE.g.mul(a).neg()),e=new EllipticCurveDigester().digestPoints([b,c.valueA]);if(!secondGenerator.mul(c.valueZ).eq(c.valueA.add(d.mul(e))))throw new Error("Zero knowledge proof did not match")}generateProofOfValue(){let a=RandomHelper.randomBigInteger(CURVE_ORDER),b=secondGenerator.mul(a),c=new EllipticCurveDigester().digestPoints([this.commitment,b]),d=c.mul(this.randomness).add(a);return{valueZ:d,valueA:b}}}class LinearZeroKnowledgeProver{constructor(a,b,c,d){this.valueCommit=a,this.linearCombinationCommit=b,this.alpha=c,this.beta=d}async evaluate(a){let b=this.valueCommit.commitment,c=this.linearCombinationCommit.commitment,d=c.neg().add(b.mul(this.alpha)).add(CURVE.g.mul(this.beta)),e=this.alpha.mul(this.valueCommit.randomness).sub(this.linearCombinationCommit.randomness).umod(CURVE_ORDER),f=RandomHelper.randomBigInteger(CURVE_ORDER),g=secondGenerator.mul(f);await a.send(safeBuffer.Buffer.from(g.encodeCompressed()));let h=new EllipticCurveDigester,i=h.digestPoints([g,d]),j=i.mul(e).add(f);await a.send(j.toArrayLike(safeBuffer.Buffer))}}const AES_BLOCK_SIZE=16;class RandomBlockGenerator{}class SecureRandomBlockGenerator extends RandomBlockGenerator{nextBlock(){return RandomHelper.randomBytes(AES_BLOCK_SIZE)}}const xorInPlace=(a,b)=>{for(let c=0;c<a.length;c++)a[c]^=b[c]},xor=(a,b)=>{let c=safeBuffer.Buffer.from(a);return xorInPlace(c,b),c},shiftLeft=(a,b)=>{let c=safeBuffer.Buffer.alloc(a.length);const d=b%8,e=Math.floor(b/8);let f;for(let g=0;g<a.length;g++)if(f=g+e,f>=a.length)c[g]=0;else{let b=a[f],e=255&b<<d;f+1<a.length&&(e|=a[f+1]>>>8-d&(255&(1<<d)-1)),c[g]=e}return c},lastBit=a=>1&a[a.length-1],increment=a=>{for(let b=a.length-1;0<=b;b--){if(255!==a[b])return void a[b]++;a[b]=0}},ByteHelper={xor,xorInPlace,shiftLeft,lastBit,increment},RESEED_LIMIT=65536,UPDATE_LIMIT=65536;class DeterministicRandomBlockGenerator extends RandomBlockGenerator{constructor(a){super(),(a===void 0||null===a)&&(a=RandomHelper.randomBytes(32)),this.entropy=a,this.cipher=crypto.createCipheriv("aes-128-ecb",safeBuffer.Buffer.alloc(AES_BLOCK_SIZE),""),this.cipher.setAutoPadding(!1),this.counter=safeBuffer.Buffer.alloc(AES_BLOCK_SIZE),this.numberOfUpdates=0,this.generatedBytes=0,this.update(a)}nextBlock(){this.generatedBytes>=UPDATE_LIMIT&&this.update(null);let a=this.cipher.update(this.counter);return this.incrementCounter(),this.generatedBytes+=AES_BLOCK_SIZE,a}update(a){this.checkReseedLimit(this.numberOfUpdates);let b=this.cipher.update(this.counter);if(this.incrementCounter(),this.counter=this.cipher.update(this.counter),null!==a){for(let c=0;c<b.length;c++)b[c]^=a[c];for(let c=0;c<this.counter.length;c++)this.counter[c]^=a[c+b.length]}this.cipher=crypto.createCipheriv("aes-128-ecb",b,""),this.numberOfUpdates++,this.generatedBytes=0}checkReseedLimit(a){if(a>=RESEED_LIMIT)throw new Error("Ran out of AES values - should not happen")}incrementCounter(){ByteHelper.increment(this.counter)}}class Garbling{constructor(a){this.aesKey=a,this.aes=crypto.createCipheriv("aes-128-ecb",this.aesKey,""),this.aes.setAutoPadding(!1),this.tweak=safeBuffer.Buffer.alloc(AES_BLOCK_SIZE)}calculateTableIndex(a,b){let c=ByteHelper.lastBit(a),d=ByteHelper.lastBit(b);return 2*c+d}createKey(a,b){let c=safeBuffer.Buffer.alloc(AES_BLOCK_SIZE);return ByteHelper.xorInPlace(c,ByteHelper.shiftLeft(a,1)),ByteHelper.xorInPlace(c,ByteHelper.shiftLeft(b,2)),ByteHelper.xorInPlace(c,this.tweak),c}encryptKey(a){return this.aes.update(a)}incrementTweak(){ByteHelper.increment(this.tweak)}}class Evaluator extends Garbling{constructor(a,b){super(a),this.CONSTANT_ZERO=safeBuffer.Buffer.alloc(0),this.CONSTANT_ONE=safeBuffer.Buffer.alloc(0),this.tables=b}and(a,b){return a===this.CONSTANT_ONE?b:b===this.CONSTANT_ONE?a:a===this.CONSTANT_ZERO||b===this.CONSTANT_ZERO?this.CONSTANT_ZERO:this.calculateOutput(a,b)}or(a,b){return a===this.CONSTANT_ONE||b===this.CONSTANT_ONE?this.CONSTANT_ONE:b===this.CONSTANT_ZERO?a:a===this.CONSTANT_ZERO?b:this.calculateOutput(a,b)}xor(a,b){return a===this.CONSTANT_ZERO?b:b===this.CONSTANT_ZERO?a:a===this.CONSTANT_ONE?this.not(b):b===this.CONSTANT_ONE?this.not(a):ByteHelper.xor(a,b)}not(a){return a===this.CONSTANT_ONE?this.CONSTANT_ZERO:a===this.CONSTANT_ZERO?this.CONSTANT_ONE:a}constantZero(){return this.CONSTANT_ZERO}constantOne(){return this.CONSTANT_ONE}calculateOutput(a,b){let c=this.tables.shift(),d=this.calculateTableIndex(a,b),e=c.slice(16*d,16*d+16),f=this.createKey(a,b),g=this.encryptKey(f);return ByteHelper.xorInPlace(g,f),ByteHelper.xorInPlace(g,e),this.incrementTweak(),g}}class Wire{constructor(a,b){this.zeroLabel=a,this.oneLabel=b}getLabel(a){return a?this.oneLabel:this.zeroLabel}}const CONSTANT_ZERO=new Wire(safeBuffer.Buffer.from([0]),safeBuffer.Buffer.from([0])),CONSTANT_ONE=new Wire(safeBuffer.Buffer.from([0]),safeBuffer.Buffer.from([0]));class Garbler extends Garbling{constructor(a,b){super(a.nextBlock()),this.tables=[],this.blockGenerator=a,this.freeXorR=this.createRandomBlock(),this.freeXorR[15]|=1,this.inputWires=Array(b);for(let c=0;c<b;c++)this.inputWires[c]=this.createWire()}and(a,b){if(a===CONSTANT_ONE)return b;if(b===CONSTANT_ONE)return a;if(a===CONSTANT_ZERO||b===CONSTANT_ZERO)return CONSTANT_ZERO;let c=this.createWire(),d=safeBuffer.Buffer.alloc(64);return this.encrypt(d,a.zeroLabel,b.zeroLabel,c.zeroLabel),this.encrypt(d,a.zeroLabel,b.oneLabel,c.zeroLabel),this.encrypt(d,a.oneLabel,b.zeroLabel,c.zeroLabel),this.encrypt(d,a.oneLabel,b.oneLabel,c.oneLabel),this.tables.push(d),this.incrementTweak(),c}or(a,b){if(a===CONSTANT_ONE||b===CONSTANT_ONE)return CONSTANT_ONE;if(b===CONSTANT_ZERO)return a;if(a===CONSTANT_ZERO)return b;let c=this.createWire(),d=safeBuffer.Buffer.alloc(64);return this.encrypt(d,a.zeroLabel,b.zeroLabel,c.zeroLabel),this.encrypt(d,a.zeroLabel,b.oneLabel,c.oneLabel),this.encrypt(d,a.oneLabel,b.zeroLabel,c.oneLabel),this.encrypt(d,a.oneLabel,b.oneLabel,c.oneLabel),this.tables.push(d),this.incrementTweak(),c}xor(a,b){return a===CONSTANT_ZERO?b:b===CONSTANT_ZERO?a:a===CONSTANT_ONE?this.not(b):b===CONSTANT_ONE?this.not(a):new Wire(ByteHelper.xor(a.zeroLabel,b.zeroLabel),ByteHelper.xor(a.oneLabel,b.zeroLabel))}not(a){if(a===CONSTANT_ONE)return CONSTANT_ZERO;if(a===CONSTANT_ZERO)return CONSTANT_ONE;let b=a.oneLabel,c=a.zeroLabel;return new Wire(b,c)}constantZero(){return CONSTANT_ZERO}constantOne(){return CONSTANT_ONE}encrypt(a,b,c,d){let e=this.createKey(b,c),f=this.encryptKey(e);ByteHelper.xorInPlace(f,e),ByteHelper.xorInPlace(f,d);let g=this.calculateTableIndex(b,c);f.copy(a,g*AES_BLOCK_SIZE,0,AES_BLOCK_SIZE)}getInput(a){return this.inputWires[a]}createWire(){let a=this.createRandomBlock(),b=new Wire(a,ByteHelper.xor(a,this.freeXorR));return b}createRandomBlock(){return this.blockGenerator.nextBlock()}}class BitHelper{static isBitSet(a,b){return 0!=(a&1<<b)}}function arraysEqual(c,a){if(c===a)return!0;if(null==c||null==a)return!1;if(c.length!==a.length)return!1;for(let b=0;b<c.length;++b)if(c[b]!==a[b])return!1;return!0}class LinearZeroKnowledgeVerifier{constructor(a,b,c,d){this.valueCommit=a,this.linearCombinationPoint=b,this.alpha=c,this.beta=d}async evaluate(a){let b=this.linearCombinationPoint.neg().add(this.valueCommit.mul(this.alpha)).add(CURVE.g.mul(this.beta)),c=await a.receive(),d=CurveUtils.decodePoint(c),e=new EllipticCurveDigester().digestPoints([d,b]),f=new BN((await a.receive())),g=b.mul(e).add(d),h=secondGenerator.mul(f);return g.eq(h)}}class AbstractCircuits{constructor(a){this.garbling=a}internalAdd(a,b,c){let d=[],e=a[0],f=b[0];d.push(this.garbling.xor(e,f));let g=this.garbling.and(e,f);for(let e=1;e<a.length;e++){let c=a[e],f=b[e],h=this.garbling.xor(g,c),i=this.garbling.xor(c,f),j=this.garbling.xor(g,i),k=this.garbling.and(h,i);d.push(j),g=this.garbling.xor(c,k)}return c&&d.push(g),d}and(a,b){return b.map(b=>this.garbling.and(a,b))}not(a){return a.map(a=>this.garbling.not(a))}}class UnsignedCircuits extends AbstractCircuits{constructor(a){super(a)}add(a,b,c){return this.internalAdd(a,b,c)}mult(a,b){const c=a.length,d=b.length;let e=[],f=a[0],g=this.and(f,b);for(let f=1;f<c;f++){e.push(g[0]);let c=this.and(a[f],b);g.push(this.garbling.constantZero()),g=this.internalAdd(g.slice(1,d+1),c,!0)}for(const c of g)e.push(c);return e}leq(a,b){let c=this.not(b);return this.garbling.not(this.internalAdd(a,c,!0)[a.length])}eq(a,b){let c=this.garbling.xor(a[0],b[0]),d=a.length;for(let e,f=0;f<d;f++)e=this.garbling.xor(a[f],b[f]),c=this.garbling.or(c,e);return this.garbling.not(c)}}function define(a,b){return{requesterInputs:a,garble:b}}const MatchingAlgorithm={EQUALS:define(1,(a,b,c,d,e)=>{let f=[],g=[];for(let h=0;h<c;h++)f.push(a(h+d)),g.push(a(h+e));let h=new UnsignedCircuits(b);return h.eq(f,g)}),RANGE:define(2,(a,b,c,d,e)=>{let f=[],g=[],h=[];for(let j=0;j<c;j++)f.push(a(j+d)),g.push(a(j+e)),h.push(a(j+e+c));let i=new UnsignedCircuits(b);return b.and(i.leq(g,f),i.leq(f,h))})};class DiffieHellmanTupleZeroKnowledgeProver{constructor(a,b,c){this.primaryGenerator=a,this.secondaryGenerator=b,this.exponent=c}async prove(a){let b=RandomHelper.randomBigInteger(CURVE_ORDER);await a.send(safeBuffer.Buffer.from(this.primaryGenerator.mul(b).encodeCompressed())),await a.send(safeBuffer.Buffer.from(this.secondaryGenerator.mul(b).encodeCompressed()));let c=new BN((await a.receive()));await a.send(b.add(c.mul(this.exponent).mod(CURVE_ORDER)).toArrayLike(safeBuffer.Buffer))}}class BatchObliviousTransferSender{constructor(a,b,c,d){this.primaryZeroGenerator=a,this.primaryOneGenerator=b,this.secondaryZeroGenerator=c,this.secondaryOneGenerator=d}static async create(a){let b=CURVE.g,c=b.mul(RandomHelper.randomBigInteger(CURVE_ORDER)),d=RandomHelper.randomBigInteger(CURVE_ORDER),e=b.mul(d),f=d.add(new BN(1)).mod(CURVE_ORDER),g=c.mul(f);return await a.send(safeBuffer.Buffer.from(c.encodeCompressed())),await a.send(safeBuffer.Buffer.from(e.encodeCompressed())),await a.send(safeBuffer.Buffer.from(g.encodeCompressed())),await new DiffieHellmanTupleZeroKnowledgeProver(CURVE.g,c,d).prove(a),new BatchObliviousTransferSender(b,c,e,g)}async sendBatch(a,b,c){this.verifyInputs(b,c);let d=b.length,e=new EllipticCurveDigester;for(let f=0;f<d;f++){let d=CurveUtils.decodePoint((await a.receive())),g=CurveUtils.decodePoint((await a.receive()));await this.sendRandom(a,e,b[f],this.primaryZeroGenerator,d,this.secondaryZeroGenerator,g),await this.sendRandom(a,e,c[f],this.primaryOneGenerator,d,this.secondaryOneGenerator,g)}}verifyInputs(a,b){if(a.length!==b.length)throw new Error("Input must be of same lengths");for(let c=0;c<a.length;c++){let d=a[c],e=b[c];if(d.length!==e.length)throw new Error("Message lengths must match");if(0>=d.length||256<d.length)throw new Error("Message length must be between 1 and 256")}}async sendRandom(a,b,c,d,e,f,g){let h=RandomHelper.randomBigInteger(CURVE_ORDER),i=RandomHelper.randomBigInteger(CURVE_ORDER),j=d.mul(h).add(f.mul(i)),k=e.mul(h).add(g.mul(i)),l=b.digestPointsToBytes([k]);await a.send(safeBuffer.Buffer.from(j.encodeCompressed()));let m=safeBuffer.Buffer.from(c);ByteHelper.xorInPlace(m,l),await a.send(m)}}class KnowledgeOfOpeningVerifier{constructor(a){this.valueCommit=a}async evaluate(a){let b=CurveUtils.decodePoint((await a.receive())),c=RandomHelper.randomBigInteger(CURVE_ORDER);await a.send(c.toArrayLike(safeBuffer.Buffer));let d=new BN((await a.receive())),e=new BN((await a.receive())),f=CURVE.g.mul(d).add(secondGenerator.mul(e)),g=this.valueCommit.mul(c).add(b);if(!f.eq(g))throw new Error("Unable to prove knowledge of opening")}}class KnowledgeOfOpeningProver{constructor(a,b){this.value=a,this.valueCommit=b}async evaluate(a){let b=RandomHelper.randomBigInteger(CURVE_ORDER),c=RandomHelper.randomBigInteger(CURVE_ORDER),d=CURVE.g.mul(b).add(secondGenerator.mul(c));await a.send(d.encodeCompressed());let e=await a.receive(),f=new BN(e);await a.send(this.value.mul(f).add(b).toArrayLike(safeBuffer.Buffer)),await a.send(this.valueCommit.randomness.mul(f).add(c).toArrayLike(safeBuffer.Buffer))}}const STATISTICAL_SECURITY_PARAMETER=40;class MatchingRequester{constructor(a){this.parameters=a,this.requesterMacInputs=MatchingRequester.computeRequesterMacInputs(a),this.inputsForProvider=MatchingRequester.computeInputsForProvider(a),this.inputsForMe=MatchingRequester.computeInputsForRequester(a)}async evaluate(a){let b=await this.computeAndSendLinearCombinations(a),c=new Garbler(new SecureRandomBlockGenerator(),this.inputsForProvider+this.inputsForMe);const d=this.garbleComputation(c);let e=new DeterministicRandomBlockGenerator,f=new Garbler(e,this.inputsForProvider+this.requesterMacInputs);const g=this.garbleMacs(f);let h=await BatchObliviousTransferSender.create(a);await this.otInputs(c,f,h,a),await MatchingRequester.sendGarbling(a,c),await MatchingRequester.sendGarbling(a,f),await this.sendComputationInput(a,c),await this.sendMacInput(a,b,f);const i=await MatchingRequester.receiveCommit(a);await new KnowledgeOfOpeningVerifier(i).evaluate(a),await MatchingRequester.sendDecodingInformation(a,g);const j=[];for(let b=0;b<this.parameters.length;b++)j.push((await MatchingRequester.receiveCommit(a)));await MatchingRequester.openLinearCombinations(a,b),await a.send(e.entropy);let k=await a.receive(),l=new BN((await a.receive()));if(PedersenCommit.verify(i,new BN(k),l),!arraysEqual(k,d.oneLabel))return!1;let m=await this.verifyZeroKnowledge(a,b,j);return await a.send([m?1:0]),m}async verifyZeroKnowledge(a,b,c){let d=!0;for(let e=0;e<b.length;e++){let f=b[e],g=this.parameters[e],h=new LinearZeroKnowledgeVerifier(g.commitment,c[e],f.alpha,f.beta),i=await h.evaluate(a);d=i&&d}return d}static async openLinearCombinations(a,b){for(let c,d=0;d<b.length;d++)c=b[d],await a.send(c.alpha.toArrayLike(safeBuffer.Buffer)),await a.send(c.alphaCommit.randomness.toArrayLike(safeBuffer.Buffer)),await a.send(c.beta.toArrayLike(safeBuffer.Buffer)),await a.send(c.betaCommit.randomness.toArrayLike(safeBuffer.Buffer))}static async sendDecodingInformation(a,b){for(let c,d=0;d<b.length;d++)c=b[d],await a.send(c.zeroLabel),await a.send(c.oneLabel)}async sendMacInput(a,b,c){let d=this.inputsForProvider;for(let e=0;e<this.parameters.length;e++){let f=this.parameters[e],g=b[e],h=f.variable.alphaLength(),i=f.variable.betaLength(),k=g.alpha;for(let b,e=0;e<h;e++)b=c.getInput(d+e),await a.send(b.getLabel(k.testn(e)));let l=g.beta;for(let b,e=0;e<i;e++)b=c.getInput(d+h+e),await a.send(b.getLabel(l.testn(e)));d+=h+i}}async sendComputationInput(a,b){let c=this.inputsForProvider;for(let d=0;d<this.parameters.length;d++){let e=this.parameters[d],f=e.matchType.toInputs(e.variable.bitLength);for(let d,e=0;e<f.length;e++)d=b.getInput(c+e),await a.send(d.getLabel(f[e]));c+=e.matchType.getAlgorithm().requesterInputs*e.variable.bitLength}}async otInputs(a,b,c,d){let e=Array(this.inputsForProvider),f=Array(this.inputsForProvider);for(let g=0;g<this.inputsForProvider;g++){let c=a.getInput(g),d=b.getInput(g),h=safeBuffer.Buffer.alloc(32),i=safeBuffer.Buffer.alloc(32);c.zeroLabel.copy(h,0,0,AES_BLOCK_SIZE),d.zeroLabel.copy(h,AES_BLOCK_SIZE,0,AES_BLOCK_SIZE),c.oneLabel.copy(i,0,0,AES_BLOCK_SIZE),d.oneLabel.copy(i,AES_BLOCK_SIZE,0,AES_BLOCK_SIZE),e[g]=i,f[g]=h}await c.sendBatch(d,f,e)}garbleMacs(a){let b=0,c=this.inputsForProvider;const d=[];for(const e of this.parameters){let f=MatchingRequester.garbleMac(b=>a.getInput(b),a,e.variable,b,c);for(const a of f)d.push(a);b+=e.variable.bitLength,c+=e.variable.alphaLength()+e.variable.betaLength()}return d}static computeInputsForRequester(a){let b=0;for(let c=0;c<a.length;c++){let d=a[c],e=d.variable;b+=d.matchType.getAlgorithm().requesterInputs*e.bitLength}return b}static computeInputsForProvider(a){let b=0;for(let c=0;c<a.length;c++){let d=a[c],e=d.variable;b+=e.bitLength}return b}async computeAndSendLinearCombinations(a){let b=[];for(let c=0;c<this.parameters.length;c++){let d=this.parameters[c],e=d.variable,f=e.alphaLength(),g=e.betaLength(),h=new LinearCombination(f,g);b.push(h),await a.send(safeBuffer.Buffer.from(h.alphaCommit.commitment.encodeCompressed())),await a.send(safeBuffer.Buffer.from(h.betaCommit.commitment.encodeCompressed())),await new KnowledgeOfOpeningProver(h.alpha,h.alphaCommit).evaluate(a),await new KnowledgeOfOpeningProver(h.beta,h.betaCommit).evaluate(a)}return b}static computeRequesterMacInputs(a){let b=0;for(let c=0;c<a.length;c++){let d=a[c],e=d.variable,f=e.alphaLength(),g=e.betaLength();b+=f+g}return b}garbleComputation(a){let b=null,c=0,d=this.inputsForProvider;for(const e of this.parameters){let f=e.variable.bitLength,g=e.matchType.getAlgorithm(),h=g.garble(b=>a.getInput(b),a,f,c,d);b=null==b?h:a.and(b,h),c+=f,d+=g.requesterInputs*f}return b}static async receiveCommit(a){return CurveUtils.decodePoint((await a.receive()))}static async sendGarbling(a,b){await a.send(b.aesKey);let c=b.tables;for(let d=0;d<c.length;d++)await a.send(c[d]);await a.send([])}static garbleMac(a,b,c,d,e){let f=MatchingRequester.buildInputs(a,e,c.alphaLength()),g=MatchingRequester.buildInputs(a,e+c.alphaLength(),c.betaLength()),h=MatchingRequester.buildInputs(a,d,c.bitLength),i=new UnsignedCircuits(b);return i.add(i.mult(f,h),g,!0)}static buildInputs(a,b,c){let d=[];for(let e=0;e<c;e++)d.push(a(b+e));return d}}class LinearCombination{constructor(a,b){this.alpha=RandomHelper.randomBigIntegerBitLength(a),this.beta=RandomHelper.randomBigIntegerBitLength(b),this.alphaCommit=new PedersenCommit(this.alpha),this.betaCommit=new PedersenCommit(this.beta)}}class MatchParameterRequester{constructor(a,b,c){this.variable=a,this.matchType=b,this.commitment=c,b.checkValidity(a)}}class RangeMatch{constructor(a,b){this.min=a,this.max=b}getAlgorithm(){return MatchingAlgorithm.RANGE}toInputs(a){let b=Array(2*a);for(let c=0;c<a;c++)b[c]=BitHelper.isBitSet(this.min,c),b[a+c]=BitHelper.isBitSet(this.max,c);return b}checkValidity(a){a.checkValidity(this.min,"Bit length of min too high"),a.checkValidity(this.max,"Bit length of max too high")}}class EqualityMatch{constructor(a){this.expected=a}getAlgorithm(){return MatchingAlgorithm.EQUALS}toInputs(a){let b=Array(a);for(let c=0;c<a;c++)b[c]=BitHelper.isBitSet(this.expected,c);return b}checkValidity(a){a.checkValidity(this.expected,"Bit length of expected too high")}}class DiffieHellmanTupleZeroKnowledgeVerifier{constructor(a,b,c,d){this.primaryGenerator=a,this.secondaryGenerator=b,this.primaryExponentiated=c,this.secondaryExponentiated=d}async verify(c){let d=CurveUtils.decodePoint((await c.receive())),a=CurveUtils.decodePoint((await c.receive())),b=RandomHelper.randomBigInteger(CURVE_ORDER);await c.send(b.toArrayLike(safeBuffer.Buffer));let e=new BN((await c.receive())),f=this.primaryGenerator.mul(e),g=d.add(this.primaryExponentiated.mul(b)),h=f.eq(g),i=this.secondaryGenerator.mul(e),j=a.add(this.secondaryExponentiated.mul(b)),k=i.eq(j);DiffieHellmanTupleZeroKnowledgeVerifier.checkMatches(h,k)}static checkMatches(a,b){if(!a||!b)throw new Error("Unable to verify diffie hellman tuple")}}class BatchObliviousTransferReceiver{constructor(a,b,c,d){this.primaryZeroGenerator=a,this.primaryOneGenerator=b,this.secondaryZeroGenerator=c,this.secondaryOneGenerator=d}static async create(a){const b=CurveUtils.decodePoint((await a.receive())),c=CurveUtils.decodePoint((await a.receive())),d=CurveUtils.decodePoint((await a.receive()));return await new DiffieHellmanTupleZeroKnowledgeVerifier(CURVE.g,b,c,d.add(b.neg())).verify(a),new BatchObliviousTransferReceiver(CURVE.g,b,c,d)}async receiveBatch(a,b){let c=[];for(const d of b){let b=RandomHelper.randomBigInteger(CURVE_ORDER),e=d?this.primaryOneGenerator:this.primaryZeroGenerator;await a.send(safeBuffer.Buffer.from(e.mul(b).encodeCompressed()));let f=d?this.secondaryOneGenerator:this.secondaryZeroGenerator;await a.send(safeBuffer.Buffer.from(f.mul(b).encodeCompressed())),c.push(b)}let d=[];const e=new EllipticCurveDigester;for(let f=0;f<b.length;f++){let g,h,i=b[f],j=CurveUtils.decodePoint((await a.receive())),k=await a.receive(),l=CurveUtils.decodePoint((await a.receive())),m=await a.receive();i?(g=l,h=m):(g=j,h=k);let n=e.digestPointsToBytes([g.mul(c[f])]);ByteHelper.xorInPlace(h,n),d.push(h)}return d}}class MatchingProvider{constructor(a){if(this.parameters=a,0===a.length)throw new Error("A minimum of one parameter must be supplied");this.requesterMacInputs=MatchingProvider.computeRequesterMacInputs(a),this.providerInputs=MatchingProvider.computeProviderInputs(a),this.numberOfParameters=a.length}async evaluate(a){let b=await this.receiveCommitsForLinearCombinations(a),c=Array(this.providerInputs),d=0,e=[],f=[],g=await BatchObliviousTransferReceiver.create(a);for(const b of this.parameters){let a=b.variable;for(let e,f=0;f<a.bitLength;f++)e=BitHelper.isBitSet(b.value,f),c[d]=e,d++}let h=await g.receiveBatch(a,c),j=0;for(const b of this.parameters){let a=b.variable;for(let b,c=0;c<a.bitLength;c++)b=h[j],j++,e.push(b.slice(0,AES_BLOCK_SIZE)),f.push(b.slice(AES_BLOCK_SIZE,32))}let i=await MatchingProvider.receiveCircuit(a),k=await MatchingProvider.receiveCircuit(a);await this.receiveComputationInputs(a,e),await this.receiveMacInputs(a,f);let l=this.evaluateComputation(e,i);const m=this.evaluateMac(f,k);let n=new BN(l),o=new PedersenCommit(n);await a.send(safeBuffer.Buffer.from(o.commitment.encodeCompressed())),await new KnowledgeOfOpeningProver(n,o).evaluate(a);let p=[],q=[],r=0;for(const b of this.parameters){let c=b.variable.betaLength()+1,d=Array(c);for(let b=0;b<d.length;b++){let c=await a.receive(),e=await a.receive();p.push(new Wire(c,e));let f=m[r];d[b]=MatchingProvider.decodeLabel(c,e,f),r++}let e=MatchingProvider.toBigInteger(d),f=new PedersenCommit(e);q.push(f)}for(const b of q)await a.send(safeBuffer.Buffer.from(b.commitment.encodeCompressed()));let s=await this.receiveOpeningsForLinearCombinations(a,b);await this.verifyMacGarbling(a,c,f,p,s),await a.send(l),await a.send(o.randomness.toArrayLike(safeBuffer.Buffer)),await this.proveZeroKnowledge(a,q,s);let t=await a.receive();return arraysEqual(t,[1])}async proveZeroKnowledge(a,b,c){for(let d=0;d<c.length;d++){let e=c[d],f=this.parameters[d],g=new LinearZeroKnowledgeProver(f.commitment,b[d],e.alpha,e.beta);await g.evaluate(a)}}async verifyMacGarbling(a,b,c,d,e){let f=new DeterministicRandomBlockGenerator((await a.receive())),g=new Garbler(f,this.providerInputs+this.requesterMacInputs),h=this.garbleMac(this.providerInputs,g);MatchingProvider.checkReceivedWires(d,h);for(let f=0;f<this.providerInputs;f++){let a=c[f],d=g.getInput(f).getLabel(b[f]);MatchingProvider.checkLabel(a,d)}let j=this.providerInputs;for(let f=0;f<this.numberOfParameters;f++){let a=this.parameters[f],b=e[f],d=a.variable.alphaLength(),h=a.variable.betaLength(),i=b.alpha;MatchingProvider.checkLabels(c,g,d,i,j);let k=b.beta,l=j+d;MatchingProvider.checkLabels(c,g,h,k,l),j+=d+h}}static checkLabels(a,b,c,d,e){for(let f=0;f<c;f++){let c=b.getInput(e+f),g=a[e+f],h=c.getLabel(d.testn(f));MatchingProvider.checkLabel(g,h)}}async receiveOpeningsForLinearCombinations(a,b){let c=[];for(let d=0;d<this.numberOfParameters;d++){let e=b[d],f=await MatchingProvider.receiveOpenCommit(a,e.alphaCommit),g=await MatchingProvider.receiveOpenCommit(a,e.betaCommit),h=new LinearCombination$1(f,g);c.push(h)}return c}static decodeLabel(a,b,c){let d;if(arraysEqual(a,c))d=!1;else if(arraysEqual(b,c))d=!0;else throw new Error("Wrong label received");return d}evaluateMac(a,b){let c=0,d=this.providerInputs;const e=[];for(const f of this.parameters){let g=MatchingRequester.garbleMac(b=>a[b],b,f.variable,c,d);for(const a of g)e.push(a);c+=f.variable.bitLength,d+=f.variable.alphaLength()+f.variable.betaLength()}return e}evaluateComputation(a,b){let c=null,d=0,e=this.providerInputs;for(const f of this.parameters){let g=f.variable.bitLength,h=f.algorithm,i=h.garble(b=>a[b],b,g,d,e);c=null==c?i:b.and(c,i),d+=g,e+=h.requesterInputs*g}return c}async receiveMacInputs(a,b){for(const c of this.parameters){let d=c.variable.alphaLength(),e=c.variable.betaLength();for(let c=0;c<d;c++)b.push((await a.receive()));for(let c=0;c<e;c++)b.push((await a.receive()))}}async receiveComputationInputs(a,b){for(const c of this.parameters){let d=c.algorithm.requesterInputs;for(let e=0;e<d*c.variable.bitLength;e++)b.push((await a.receive()))}}async receiveCommitsForLinearCombinations(a){let b=[];for(let c=0;c<this.numberOfParameters;c++){let c=CurveUtils.decodePoint((await a.receive())),d=CurveUtils.decodePoint((await a.receive()));b.push(new LinearCombinationCommit(c,d)),await new KnowledgeOfOpeningVerifier(c).evaluate(a),await new KnowledgeOfOpeningVerifier(d).evaluate(a)}return b}static computeProviderInputs(a){let b=0;for(const c of a)b+=c.variable.bitLength;return b}static computeRequesterMacInputs(a){let b=0;for(const c of a)b+=c.variable.alphaLength()+c.variable.betaLength();return b}static checkReceivedWires(a,b){if(a.length!==b.length)throw new Error("Mismatching in wire count");for(let c=0;c<b.length;c++){let d=a[c],e=b[c],f=arraysEqual(d.zeroLabel,e.zeroLabel)&&arraysEqual(d.oneLabel,e.oneLabel);if(!f)throw new Error("Non matching output wires")}}static checkLabel(a,b){if(!arraysEqual(a,b))throw new Error("Wrong label received")}garbleMac(a,b){let c=0,d=a;const e=[];for(const f of this.parameters){let a=MatchingRequester.garbleMac(a=>b.getInput(a),b,f.variable,c,d);for(const b of a)e.push(b);c+=f.variable.bitLength,d+=f.variable.alphaLength()+f.variable.betaLength()}return e}static async receiveOpenCommit(a,b){let c=new BN((await a.receive())),d=new BN((await a.receive()));return PedersenCommit.verify(b,c,d),c}static toBigInteger(a){let b=safeBuffer.Buffer.alloc(MatchingProvider.bytesNeededForBits(a.length-1)),c=b.length-1,d=0;for(const e of a){if(e){let a=1<<d;b[c]^=a}d++,8<=d&&(c--,d=0)}return new BN(b)}static bytesNeededForBits(a){return(a-1)/8+1}static async receiveCircuit(a){let b=await a.receive(),c=[],d=!1;for(;!d;){let b=await a.receive();0===b.length?d=!0:c.push(b)}return new Evaluator(b,c)}}class LinearCombination$1{constructor(a,b){this.alpha=a,this.beta=b}}class MatchParameterProvider{constructor(a,b,c,d){this.variable=b,this.value=c,this.commitment=d,this.algorithm=a,b.checkValidity(c,"Bit length of value too high")}}class LinearCombinationCommit{constructor(a,b){this.alphaCommit=a,this.betaCommit=b}}function define$1(a){return{bitLength:a,alphaLength:()=>STATISTICAL_SECURITY_PARAMETER,betaLength:()=>STATISTICAL_SECURITY_PARAMETER+a,checkValidity:(b,c)=>{let d=(1<<a)-1;if(0>b||b>d)throw new Error(b+" is larger than allowed "+d+" - "+c)}}}const MatchingVariable={BIRTH_YEAR:define$1(9),GENDER:define$1(1),NATIONALITY:define$1(10)},SMPC={MatchingAlgorithm,MatchingVariable,MatchingProvider,MatchParameterProvider,MatchingRequester,MatchParameterRequester,RangeMatch,EqualityMatch,PedersenCommit};module.exports=SMPC;